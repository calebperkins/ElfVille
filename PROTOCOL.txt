Goals of the Authentication Protocol
===========================
When either of the below protocols (both authentication and  end in success, the client and user should believe that the server is using shared key S_C and that the server has authenticated this user under username (with username’s credentials); the server should believe that it is communicating with a client that is using shared key S_C that is in posession of username’s password and thus treat that client as username. Both client and server should believe that S_C is only known by either client or server.


Assumptions and Enrollment Protocol
============================
We assume that messages encrypted under the server’s public key S_p can only be decrypted by the server. We assume that if a client that sends a username and password that (after peppered hashing) matches to a username in the database, then that client is acting on behalf of that user (basically, we assume passwords can’t be acquired by the adversary through means other than communications that use our protocol (we don’t protect against keyloggers or phishing attempts)).

The enrollment protocol is identical to the sign in protocol insofar as message passing, but the database does different things with the given username and password. During sign in it’s checked that there’s a username in the database that is associated with a peppered hash of the password given in the message. During sign up, it’s checked that there is no such username in the database (if there is then it reports failure) and then adds this username to the database and associates it with a peppered hash of the given password.


Protocols as Message-Exchange Steps
==============================
Sign in
C: Client, S: Server, U: User, 
C → U: id?, password?
U → C: username, password
C → S: {username, password, auth_time, S_C, session_nonce}S_p
if username is in the database and a peppered hash of the password is in the database then
S → C: {success}S_C
else
        S → C: {failure}S_C

SIGN UP
C: Client, S: Server, U: User, 
C → U: id?, password?
U → C: username, password
C → S: {username, password, auth_time, S_C, session_nonce}S_p
if username is not in the database add it with a peppered hash of the password
S → C: {success}S_C
else
        S → C: {failure}S_C

 Justification of Nonce Sizes and Key Lengths
===================================
shared_nonce: incremented with each messaged passed (both from server to client and from client to server). Its size is 32 bits. Since its only purpose is to prevent replay attacks after the session key has been established (for the message before, that’s handled by an included time), the only requirement is that it is long enough that there will be no repeats within a session, and at about 4.3 billion options it’d take about 490 days at the unreasonable rate of one hundred messages per second. This means it’s sufficiently long, and 32 bits is nice because it falls on a word boundary so we can treat it as an int.

S_p: Server’s public key. Its length is 4096 bits. Not so long that it takes unreasonable amounts of time to decrypt (less than a second, which would become a problem if we had tons of users, but we’d reach socket limit before that), but long enough that we can encrypt our entire initial message (which includes a lot for the sake of simplicity of programming).

S_C: Session key for communication between the client and the server. Its length is 128 bits. 


Key Components (Itemization)
=============
S_p: server public key
* stored in client package as file elfville.pub.der
* used to encrypt transfer of session key by sockentController (which uses PublicKeyCipher.java both are) in elfville.client; see write(Request req) method.

auth_time: date and time at authentication
* created by the client for for each new session at Signin/Signup time. 
* see SignInRequest and SignUpRequest in elfville.protocol

session_nonce: random number
* created by the client for each new session
* generated by the java SecureRandom class.
* size: 32 bit. 
* see LoginPanel.java  and RegistrationPanel.java in package elfville.client.views.subcomponents, specifically the function actionPerformed(ActionEvent e)


shared_key: the shared key agreed by both client and server
* created by the client for each new session
* generated by the java KeyGenerator class which uses SecureRandom internally.
* key size: 128 bit
* see LoginPanel.java  and RegistrationPanel.java in package elfville.client.views.subcomponents, specifically the function actionPerformed(ActionEvent e)

Signin / Signup packet
{username, password, auth_time, shared_key, session_nonce}S_p
* created by the client for authentication of a new session
* encrypted by the server’s public key S_p
* Each field is limited to fit size so the whole packet would not exceed 512 - RSA overhead (11 bytes)
* See SignInRequest.java and SignUpRequest.java in package elfville.protocol

Message packet
{request/response, shared_nonce}shared_key
* the messages passed between the server and client are encrypted by the agreed shared_key
* the shared nonce is incremented with each message passed. Server and client should check that it has been incremented.
* See... well requests and responses are created and received everywhere (see protocol package for those files). SocketControler.java in eflville.client is responsible for encrypting and decrpyting for the client, see function write(Request req). Session.java in elfville.server is responsible for encrypting and decrypting for the server, see function run().

Since the above itemizing of the objects used seems to include mention almost all of the relevant client classes (by virtue of them creating most of those objects), I’ll mention the remaining classes that use them (mostly server, don’t create them).

SharedKeyCipher.java
* a class in eflville.protocol.utils
* this class deals with everything to do with the key shared between client and server, including creation, encryption (of both responses and requests), and decryption (of both responses and requests).

PKcipher.java
* a class in elfville.server
* this class is used to decrypt sign in and sign up messages from clients.

signIn(SignInRequest r, CurrentUserProfile currentUser)
* a function in AuthenticationProtocol.java in package elfville.server.controller that takes a sign in request and forms the response that is either success or failure (the only relevant thing this does is call findByUserNameHashedPassword).

findByUserNameHashedPassword(String username, String password)
* a function in UserDB.java in package elville.server.database
* gets the user object associated with username out of the database
* checks that a peppered hash of password is found in database (via function checkPepperedPassword), and if so returns the user object

checkPepperedPassword(String password, String hashedPassword)
* a function found in SecurityUtils.java in package elfville.server.controller
* checks that a peppered hash of password is equal to hashedPassword

signUp(SignUpRequest r, CurrentUserProfile currentUser)
* a function in AuthenticationControl.java in package elfville.server.controller
* checks that the requested username does not already exist (if so responds failure) and is at least 4 characters and max 20
* checks that requested password has 8 chars min, 20 chars max, and includes a digit or symbol, but no weird characters like newline, tab, end of line, and then uses generateRandomPepper to get what should be stored in database, and stores it all in database.

generateRandomPepper(String password)
*  uses secureRandomInt to get a random pepper, then hashes the pepper and password and returns it. In SecurityUtils.java in elfville.server package.
